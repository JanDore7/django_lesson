1) pip install django==4.2.1  Установим фраемворк

* django-admin - выведет в консоль все доступные команды

2) django-admin startproject [название проекта]
3) python3 manage.py runserver - запуск проекта опционально можно добавть порт
	python3 manage.py runserver [port] 
	
	
4) python3 manage.py startapp [название приложения]

5) Регистрируем приложение в settings.py [папка/файл/название класса]
	'women.apps.WomenConfig'
	
6) Определение функций def index(request): где request это ссылка на класс 
	HttpRequest который содержит в себе всю информацию о запросе. (сессии,
	куки и т.д) Через эту переменную, будет доступна вся информация о
	текущем запросе.


7) path('', include('women.urls')) используя функцию include все маршруты
	которые относятся к приложению women выносятя в отдельный файл.
	Кроме того можно добавить суфикс, например
	path('women', include('women.urls')) и данный суфикс добавиться ко
	всем маршрутам имеющим отношение к women.urls.py
 
 8) Конверторы и их типы:
	    int: Используется для сопоставления целых чисел в URL. Например,
	    path('articles/<int:article_id>/', views.article_detail).
	    

    	    str: Сопоставляет любую строку в URL. Например, path('products/
    	    <str:product_slug>/', views.product_detail).
    	    

            slug: Похож на str, но обычно используется для сопоставления
            строк, представляющих "слаги" или человеко-читаемые URL-адреса.
            
            Например,path('articles<slug:article_slug>/',
            views.article_detail).

            uuid: Используется для сопоставления UUID (Уникальных
            идентификаторов) в URL. Например, path('items/<uuid:item_id>/',
            views.item_detail).

            path: По умолчанию используется для сопоставления строк без
            прямого слеша ("/"). Например, path('pages/<path:page_path>/',
            views.page_detail).

            date: Сопоставляет дату в URL. Например, path('events/
            <date:event_date>/', views.event_detail).

            slugify: Похож на slug, но генерирует слаг автоматически на 
            основе переданной строки.

            custom converters: Вы также можете создать собственные
            пользовательские конвертеры, определив класс конвертера и его
            методы to_python и to_url. Это полезно, если у вас есть
            нестандартные типы данных, которые вы хотите использовать в URL.

9) В urls важно располагать пути в строгом порядке, поскольку джанго ищет маршруты с верху вниз.


10) Функция re_path позволяет использовать регулярные выражения.

11) register_converter(converters.MyCustomConverter, 'year4') где 'year4',
	произвольное имя которое удет использоваться при определении адресов
	url. 
	
12) При переключении проекта из режима разработки нербходимо заполнить
 	разршенные хосты ALLOWED_HOSTS = ['127.0.0.1']
 	
13) Обработчики и не только https://docs.djangoproject.com/en/4.2/ref/urls/

14) 301 - страница перемещена на другой постоянный url; 302 - перемещена
	времено на другой url.
 
 	По умолчанию функция redirect() перемещает страницу с кодом 302,
 	если добавить аргумент permanent=True, то код смениться на 301,
 	функция первым аргументом может принимать как url например "/", 
 	так и название другой функции привязанной к url 
 	redirect(index, permanent=True), кроме это можно прописать имя
 	маршрута заданное в файле urls что на самом деле является самым
 	предпочтительным вариантом,так же обязательное условие данной
 	функции это вызов ее через return.

	Если у маршрута есть дополнительный параметр, например slug то 
	необходимо и в функцию добавлять параметр например 
	redirect('cats', 'qq')
 	
 15) Функция reverse в Django используется для построения URL-адреса на
 	основе имени URL-шаблона и аргументов (параметров) для этого шаблона.
 	Это позволяет вам создавать URL-адреса динамически вместо их
 	хардкодного указания в вашем коде.
 	
 	В вашем конкретном примере, reverse('cats', args=('music',))
 	означает следующее:
 	
 	'cats' - это имя URL-шаблона, который вы хотите использовать для
 	построения URL-адреса. Ваш URL-шаблон с именем 'cats'
 	 
 	должен быть определен в файлах маршрутов вашего Django-приложения.
 	
 	args=('music',) - это кортеж аргументов, которые вы передаете в
 	URL-шаблон. В данном случае, вы передаете один аргумент 'music'
 	в URL-шаблон с именем 'cats'.
 	
 	Функция reverse найдет URL-шаблон с именем 'cats' и подставит
 	значение 'music' в соответствующее место в URL-шаблоне, 
 	заменив, например, <slug:cat_slug>. Затем она вернет полный 
 	URL-адрес.

16) 301 и 302 при помощи классов. HttpResponseRedirect - 302;
	HttpResponsePtrmanentRedirect - 301
	Пример: HttpResponseRedirect(uri)
 	

17) Папку templates создаем в корне программы и там уже создать подкаталог
	программы  render_to_string('путь к
	шаблону index.html')


18) Можно упростить код :
	t = render_to_string('women/index.html')
    	return HttpResponse(t)
    	
    Исползовав фукнкцию render(request, 'women/index.html')
    
    
19) В settings в строке TEMPLATES прописаныы все настройки шаблонов,
	
	
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
	
	

    'BACKEND': Это параметр, который определяет, какой бэкенд шаблонизации будет использоваться. В вашем случае, 'django.template.backends.django.DjangoTemplates' означает, что вы используете стандартный бэкенд Django для шаблонизации.

    'DIRS': Это список каталогов, где Django будет искать шаблоны. Если список пуст, как в вашем случае ('DIRS': []), Django будет искать шаблоны в каталогах приложений (параметр 'APP_DIRS': True). Если вы хотите добавить дополнительные каталоги для поиска шаблонов, вы можете указать их здесь.

    'APP_DIRS': Этот параметр указывает, следует ли Django искать шаблоны в каталогах приложений. Установка 'APP_DIRS': True означает, что Django будет искать шаблоны в каталогах приложений. Это удобно, так как многие приложения в Django поставляются со своими собственными шаблонами.

    'OPTIONS': Этот параметр содержит дополнительные параметры для настройки шаблонов. В вашем случае, вы указываете набор контекстных процессоров, которые предоставляют дополнительные переменные для шаблонов. Например, 'django.template.context_processors.debug' предоставляет переменную debug для отладки, а 'django.template.context_processors.request' предоставляет доступ к объекту request в шаблонах.


Синтаксис написания тега {% название тега [параметры] %}


<ul>
    {% for p in posts %}
    <li>
        <h2>{{ p.title }}</h2>
        <p>{{ p.content }}</p>
        {% if not forloop.last %}
        <hr>
        {% endif %}
    </li>
    {% endfor %}
</ul>

forloop - это объект, предоставляемый в шаблонах Django, который представляет информацию о текущей итерации в цикле. Этот объект позволяет вам получить информацию о текущей итерации, такую как номер, индекс, количество элементов и другие связанные значения.

forloop содержит следующие атрибуты:

    forloop.counter: Номер текущей итерации (начиная с 1).

    forloop.counter0: Номер текущей итерации, начиная с 0.

    forloop.revcounter: Номер текущей итерации в обратном порядке (начиная с 1).

    forloop.revcounter0: Номер текущей итерации в обратном порядке, начиная с 0.

    forloop.first: Булево значение, которое истинно (True), если это первая итерация, иначе ложно (False).

    forloop.last: Булево значение, которое истинно (True), если это последняя итерация, иначе ложно (False).

    forloop.parentloop: Объект forloop для внешнего цикла, если шаблон вложен в другой цикл.




Шаблонный тег url прежде следует его импортировать если используется старая версия джанго
{% load url from future %}, а затем уже прописываем {% url 'название маршрута (с urls.py)' аргументы если есть  %}


Базовый шаблон создается на уровне root после чего необходимо внести данные о его пути в settings


TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [
            BASE_DIR / 'templates' <- сюда
        ],


{% block [название] %} {% endblock %} позволяет вставлять информацию из дочерних шаблонов.

{% extends [путь до шаблона)] %} позволяет использовать базовый шаблон.

{% include [путь к файлу] %} используется для вставки содержимого другого шаблона в текущий шаблон. Он позволяет создавать более модульные и переиспользуемые шаблоны, разделяя их на более мелкие компоненты.

{% extends [путь до шаблона)] only %} если к шаблону добавть only то не возможно будет работать с переменными 

также после with можно добавить свои переменные, например titlt2='sldfhg'


режим отладки : статические файлы ищутся во всех каталогах static приложений и во всех возможных катаолгах static внешних модулей (например админки)
режим продакшен: статические файлы беруться из папки static, расположенной в каталоге всего проекта
(корень проекта/static) Чтобы переместить все статические файлы на сервере в нужную папку, используется команда python manage.py collectstatic

STATIC_URL - префикс URL для статических файлов
STATIC_ROOT - путь к общей статической папке, формируемой при запуске команды collectstatic 
STATICFILES_DIRS - список дополнительных не стандартных путей к статическим файлам, используемых для сбора и режима отладки.

подключить статику {% load static %} ... {% static [путь к файлу] %}, пример
<link type="text/css" href="{% static 'women/css/styles.css' %}" rel="stylesheet">

{{p.content|linebreaks|truncatewords:40}}
linebreaks: Это фильтр, предназначенный для преобразования переводов строк в теги <br> в тексте. Т.е соблюдается формат переноса стороки как в источнике. Таким образом, если в p.content есть переводы строк, они будут отображены как разрывы строк в HTML.
truncatewords:40: Это фильтр, предназначенный для обрезки текста до определенного количества слов. В данном случае, текст будет обрезан до 40 слов.

simple tags - простые теги, Они позволяют разработчикам создавать собственные шаблонные теги с минимальными усилиями.
Простые теги обычно используются для вставки логики в шаблоны и выполнения некоторых действий на уровне шаблона.

inclusion tags - позволяют встраивать другие шаблоны в текущий шаблон.
Они полезны, когда вам нужно многократно использовать фрагмент HTML в различных частях вашего проекта.
Inclusion tags принимают аргументы и возвращают фрагмент HTML, который затем вставляется в родительский шаблон.


Все теги должны создаваться в каталоге templatetags в диррекотрии приложения, объязательно католог должен быть пакетом , т.е иметь __init__.py


Что бы добавить тег, необходимо его загрузить на страницу {% load [название файла где регистрирровался тег] %}

Если к тегу добавить as то все данные тега переместятся в переменную. {% get_categories as categoties%} переменную уже можно итерировать


{% get_categories as categories %}

		<li class="selected">Все категории</li>
		{% for cat in categories %}
		<li><a href="#">{{ cat.name }}</a></li>
		{% endfor %}

inclusion tags - позволяет возвращать не прото данные, а фрагмент HTML страницы.




















